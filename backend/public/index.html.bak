// index.js
// ====================================================================
// FRONTEND CONFIGURATION (Matching Your Backend)
// ====================================================================
const BASE_URL = 'http://localhost:9090';
const WS_URL = 'ws://localhost:9090/ws';
const USER_DATA_API = `${BASE_URL}/user/data`;
const VIDEO_STREAM_API = `${BASE_URL}/api/videos`;

let websocketInstance = null;
let reconnectAttempts = 0;
const MAX_RECONNECT_DELAY = 30000;
let intrusionChart = null;
const MAX_DATA_POINTS = 30;

const MAX_STORED_FEEDBACKS = 10;
const FEEDBACKS_STORAGE_KEY = 'chakravyuha_feedbacks';
const VIDEO_TIMESTAMP_MAP_KEY = 'chakravyuha_video_timestamps';
const MAX_DISPLAYED_LOGS = 50;

// ====================================================================
// VIDEO TIMESTAMP MAPPING
// ====================================================================
function storeVideoTimestamp(videoFilename, originalTimestamp) {
    try {
        const map = JSON.parse(localStorage.getItem(VIDEO_TIMESTAMP_MAP_KEY) || '{}');
        map[videoFilename] = originalTimestamp;
        localStorage.setItem(VIDEO_TIMESTAMP_MAP_KEY, JSON.stringify(map));
        console.log('[Storage] Stored video timestamp mapping:', videoFilename, '‚Üí', originalTimestamp);
    } catch (error) {
        console.error('[Storage] Error storing video timestamp:', error);
    }
}

function getVideoTimestamp(videoFilename) {
    try {
        const map = JSON.parse(localStorage.getItem(VIDEO_TIMESTAMP_MAP_KEY) || '{}');
        return map[videoFilename] || null;
    } catch (error) {
        console.error('[Storage] Error getting video timestamp:', error);
        return null;
    }
}

function updateProbabilityIndicator(probability) {
    const indicator = document.getElementById("probabilityIndicator");
    const symbol = document.getElementById("probSymbol");
    const text = document.getElementById("probText");
    
    if (!indicator || !symbol || !text) return;
    
    indicator.className = "probability-indicator";
    
    if (probability < 60) {
        indicator.classList.add("safe");
        symbol.textContent = "üü¢";
        text.textContent = `Safe (${probability.toFixed(1)}%)`;
    } else if (probability < 70) {
        indicator.classList.add("caution");
        symbol.textContent = "üü°";
        text.textContent = `Caution (${probability.toFixed(1)}%)`;
    } else {
        indicator.classList.add("alert");
        symbol.textContent = "üî¥";
        text.textContent = `Alert (${probability.toFixed(1)}%)`;
    }
}

// ====================================================================
// LOCALSTORAGE HELPERS FOR FEEDBACK REQUESTS
// ====================================================================
function loadStoredFeedbacks() {
    try {
        const stored = localStorage.getItem(FEEDBACKS_STORAGE_KEY);
        return stored ? JSON.parse(stored) : [];
    } catch (error) {
        console.error('[Storage] Error loading feedbacks:', error);
        return [];
    }
}

function saveStoredFeedbacks(feedbacks) {
    try {
        const trimmed = feedbacks.slice(0, MAX_STORED_FEEDBACKS);
        localStorage.setItem(FEEDBACKS_STORAGE_KEY, JSON.stringify(trimmed));
    } catch (error) {
        console.error('[Storage] Error saving feedbacks:', error);
    }
}

function addFeedbackToStorage(feedbackData) {
    const feedbacks = loadStoredFeedbacks();
    feedbacks.unshift({
        time: feedbackData.time,
        trigger: feedbackData.trigger,
        video: feedbackData.video,
        training_count: feedbackData.training_count,
        operation_mode: feedbackData.operation_mode,
        probability: feedbackData.probability,
        timestamp: Date.now()
    });
    saveStoredFeedbacks(feedbacks);
    storeVideoTimestamp(feedbackData.video, feedbackData.time);
}

function restoreStoredFeedbacks() {
    const feedbacks = loadStoredFeedbacks();
    if (feedbacks.length === 0) {
        console.log('[Storage] No stored feedbacks found');
        return;
    }
    
    console.log('[Storage] Restoring', feedbacks.length, 'feedbacks');
    feedbacks.forEach(feedback => {
        displayFeedbackRequest(feedback, false);
    });
}

function clearAllFeedbacks() {
    if (confirm('Clear all feedback requests?')) {
        localStorage.removeItem(FEEDBACKS_STORAGE_KEY);
        const feedbackContainer = document.getElementById('triggerInfo');
        if (feedbackContainer) {
            feedbackContainer.innerHTML = '<p style="opacity: 0.6;">No pending feedback requests</p>';
        }
        console.log('[Storage] All feedbacks cleared');
    }
}

// ====================================================================
// DISPLAY FEEDBACK REQUEST CARD
// ====================================================================
function displayFeedbackRequest(message, addToStorage = true) {
    const feedbackContainer = document.getElementById('triggerInfo');
    if (!feedbackContainer) {
        console.error('Feedback container not found');
        return;
    }

    if (feedbackContainer.querySelector('p')) {
        feedbackContainer.innerHTML = '';
    }

    const feedbackCard = document.createElement('div');
    feedbackCard.className = 'feedback-card';
    feedbackCard.setAttribute('data-video-filename', message.video);

    const trainingBadge = message.operation_mode === 'training' 
        ? `<span class="mode-badge training">Training Phase (${message.training_count}/100)</span>` 
        : `<span class="mode-badge operational">Operational</span>`;

    const probabilityBadge = message.probability 
        ? `<span class="probability-badge">${message.probability.toFixed(1)}% confidence</span>` 
        : '';

    feedbackCard.innerHTML = `
        <div class="feedback-header">
            <span class="feedback-time">${formatTimestamp(message.time)}</span>
            ${trainingBadge}
            ${probabilityBadge}
        </div>
        <div class="feedback-body">
            <span class="trigger-type">${formatTriggerType(message.trigger)}</span>
            <span class="feedback-prompt">Click to review video</span>
        </div>
    `;

    feedbackCard.addEventListener('click', function() {
        const videoFile = this.getAttribute('data-video-filename');
        window.location.href = `video/video-viewer.html?video=${encodeURIComponent(videoFile)}`;
    });

    feedbackContainer.insertBefore(feedbackCard, feedbackContainer.firstChild);

    if (addToStorage) {
        addFeedbackToStorage(message);
    }

    const allCards = feedbackContainer.querySelectorAll('.feedback-card');
    if (allCards.length > MAX_STORED_FEEDBACKS) {
        allCards[allCards.length - 1].remove();
    }
}

// ====================================================================
// WEBSOCKET CONNECTION
// ====================================================================
function connectWebSocket() {
    try {
        console.log('[WS] Connecting to:', WS_URL);
        websocketInstance = new WebSocket(WS_URL);
        
        websocketInstance.onopen = () => {
            console.log('[WS] Connected');
            reconnectAttempts = 0;
            updateConnectionStatus('connected');
        };
        
        websocketInstance.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                console.log('[WS] Received:', data);
                
                if (data.type === 'detection') {
                    updateChart(data.probability);
                    if (data.probability !== undefined) {
                        updateProbabilityIndicator(data.probability);
                    }
                    addLogEntry(data);
                } else if (data.type === 'feedbackrequest') {
                    console.log('[Feedback] Request received:', data);
                    displayFeedbackRequest(data);
                }
            } catch (error) {
                console.error('[WS] Error parsing message:', error);
            }
        };
        
        websocketInstance.onclose = () => {
            console.log('[WS] Disconnected');
            updateConnectionStatus('disconnected');
            attemptReconnect();
        };
        
        websocketInstance.onerror = (error) => {
            console.error('[WS] Error:', error);
            updateConnectionStatus('error');
        };
        
    } catch (error) {
        console.error('[WS] Connection failed:', error);
        attemptReconnect();
    }
}

function attemptReconnect() {
    reconnectAttempts++;
    const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), MAX_RECONNECT_DELAY);
    console.log(`[WS] Reconnecting in ${delay/1000}s (attempt ${reconnectAttempts})`);
    
    setTimeout(() => {
        connectWebSocket();
    }, delay);
}

function updateConnectionStatus(status) {
    const statusElement = document.getElementById('connectionStatus');
    if (!statusElement) return;
    
    statusElement.className = `status-indicator ${status}`;
    
    const statusText = {
        'connected': 'Connected',
        'disconnected': 'Disconnected',
        'error': 'Connection Error'
    };
    
    statusElement.textContent = statusText[status] || 'Unknown';
}

// ====================================================================
// CHART MANAGEMENT
// ====================================================================
function initChart() {
    const ctx = document.getElementById('intrusionChart');
    if (!ctx) {
        console.error('Chart canvas not found');
        return;
    }
    
    intrusionChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: [],
            datasets: [{
                label: 'Intrusion Probability (%)',
                data: [],
                borderColor: 'rgb(220, 53, 69)',
                backgroundColor: 'rgba(220, 53, 69, 0.1)',
                borderWidth: 2,
                tension: 0.4,
                fill: true
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100,
                    ticks: {
                        callback: function(value) {
                            return value + '%';
                        }
                    }
                },
                x: {
                    display: false
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top'
                }
            },
            animation: {
                duration: 300
            }
        }
    });
}

function updateChart(probability) {
    if (!intrusionChart) return;
    
    const timestamp = new Date().toLocaleTimeString();
    
    intrusionChart.data.labels.push(timestamp);
    intrusionChart.data.datasets[0].data.push(probability);
    
    if (intrusionChart.data.labels.length > MAX_DATA_POINTS) {
        intrusionChart.data.labels.shift();
        intrusionChart.data.datasets[0].data.shift();
    }
    
    intrusionChart.update('none');
}

// ====================================================================
// ACTIVITY LOG
// ====================================================================
function addLogEntry(data) {
    const logContainer = document.getElementById('logEntries');
    if (!logContainer) return;
    
    const logEntry = document.createElement('div');
    logEntry.className = 'log-entry';
    
    const timestamp = new Date().toLocaleTimeString();
    const probabilityClass = data.probability >= 70 ? 'high' : data.probability >= 60 ? 'medium' : 'low';
    
    logEntry.innerHTML = `
        <span class="log-time">${timestamp}</span>
        <span class="log-probability ${probabilityClass}">${data.probability.toFixed(1)}%</span>
        <span class="log-status">${data.label === 1 ? '‚ö†Ô∏è Alert' : '‚úì Normal'}</span>
    `;
    
    logContainer.insertBefore(logEntry, logContainer.firstChild);
    
    const entries = logContainer.querySelectorAll('.log-entry');
    if (entries.length > MAX_DISPLAYED_LOGS) {
        entries[entries.length - 1].remove();
    }
}

// ====================================================================
// USER DATA FETCH
// ====================================================================
async function fetchUserData() {
    try {
        const response = await fetch(USER_DATA_API);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        const data = await response.json();
        console.log('[User Data]', data);
        displayUserData(data);
    } catch (error) {
        console.error('[User Data] Fetch failed:', error);
    }
}

function displayUserData(data) {
    const container = document.getElementById('userInfo');
    if (!container) return;
    
    container.innerHTML = `
        <div class="user-data-item">
            <strong>Name:</strong> ${data.name || 'N/A'}
        </div>
        <div class="user-data-item">
            <strong>Location:</strong> ${data.location || 'N/A'}
        </div>
        <div class="user-data-item">
            <strong>System:</strong> ${data.system_mode || 'N/A'}
        </div>
    `;
}

// ====================================================================
// UTILITY FUNCTIONS
// ====================================================================
function formatTimestamp(timestamp) {
    try {
        const date = new Date(timestamp);
        return date.toLocaleString('en-IN', {
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            day: '2-digit',
            month: 'short',
            year: 'numeric'
        });
    } catch (error) {
        return timestamp;
    }
}

function formatTriggerType(trigger) {
    const triggerMap = {
        'motion': 'Motion Detected',
        'door': 'Door Sensor',
        'risk_threshold': 'Risk Threshold',
        'high_probability': 'High Probability'
    };
    return triggerMap[trigger] || trigger;
}

// ====================================================================
// INITIALIZATION
// ====================================================================
document.addEventListener('DOMContentLoaded', () => {
    console.log('[Init] Dashboard loading...');
    
    initChart();
    connectWebSocket();
    fetchUserData();
    restoreStoredFeedbacks();
    
    const clearBtn = document.getElementById('clearFeedbacksBtn');
    if (clearBtn) {
        clearBtn.addEventListener('click', clearAllFeedbacks);
    }
    
    console.log('[Init] Dashboard ready');
});

